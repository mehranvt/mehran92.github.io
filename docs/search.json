[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "mehran92.github.io",
    "section": "",
    "text": "Classification\n\n\n\n\n\n\n\ncode\n\n\nanalysis\n\n\n\n\n\n\n\n\n\n\n\nDec 7, 2023\n\n\nMehran Islam\n\n\n\n\n\n\n  \n\n\n\n\nPost With Code\n\n\n\n\n\n\n\nnews\n\n\ncode\n\n\nanalysis\n\n\n\n\n\n\n\n\n\n\n\nDec 7, 2023\n\n\nHarlow Malloc\n\n\n\n\n\n\n  \n\n\n\n\nWelcome To My Blog\n\n\n\n\n\n\n\nnews\n\n\n\n\n\n\n\n\n\n\n\nDec 4, 2023\n\n\nTristan O’Malley\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/post-with-code/index.html",
    "href": "posts/post-with-code/index.html",
    "title": "Post With Code",
    "section": "",
    "text": "This is a post with executable code.\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "This is the first post in a Quarto blog. Welcome!\n\nSince this post doesn’t specify an explicit image, the first image in the post will be used in the listing page of posts."
  },
  {
    "objectID": "posts/Classification/index.html",
    "href": "posts/Classification/index.html",
    "title": "Classification",
    "section": "",
    "text": "Classification Post\nImport the required librariesundefined\n\nimport pandas as pd\n\n\nimport numpy as np\nimport matplotlib.pyplot as pl\nimport seaborn as sns\n\nRead data from file and identify null values\n\ndata=pd.read_csv('athlete_events.csv', index_col=\"ID\")\n\n{data.apply(pd.isnull).sum()/data.shape[0]}\n\nathletes= data[[\"Team\",\"Sex\", \"Season\",\"Sport\",\"Medal\"]].copy()\n\n#converting into column\nathletes.columns = [\"country\",\"sex\",\"season\", \"sport\",\"medal\"]\n\nathletes\n\n\n\n\n\n\n\n\ncountry\nsex\nseason\nsport\nmedal\n\n\nID\n\n\n\n\n\n\n\n\n\n1\nChina\nM\nSummer\nBasketball\nNaN\n\n\n2\nChina\nM\nSummer\nJudo\nNaN\n\n\n3\nDenmark\nM\nSummer\nFootball\nNaN\n\n\n4\nDenmark/Sweden\nM\nSummer\nTug-Of-War\nGold\n\n\n5\nNetherlands\nF\nWinter\nSpeed Skating\nNaN\n\n\n...\n...\n...\n...\n...\n...\n\n\n135569\nPoland-1\nM\nWinter\nLuge\nNaN\n\n\n135570\nPoland\nM\nWinter\nSki Jumping\nNaN\n\n\n135570\nPoland\nM\nWinter\nSki Jumping\nNaN\n\n\n135571\nPoland\nM\nWinter\nBobsleigh\nNaN\n\n\n135571\nPoland\nM\nWinter\nBobsleigh\nNaN\n\n\n\n\n271116 rows × 5 columns\n\n\n\n\nathletes.apply(pd.isnull).sum()/athletes.shape[0]\n\ncountry    0.000000\nsex        0.000000\nseason     0.000000\nsport      0.000000\nmedal      0.853262\ndtype: float64\n\n\n\nathletes = athletes[athletes['medal'].isin(['Gold', 'Silver', 'Bronze'])].dropna(subset=['medal'])\n\n\nathletes\n\n\n\n\n\n\n\n\ncountry\nsex\nseason\nsport\nmedal\n\n\nID\n\n\n\n\n\n\n\n\n\n4\nDenmark/Sweden\nM\nSummer\nTug-Of-War\nGold\n\n\n15\nFinland\nM\nSummer\nSwimming\nBronze\n\n\n15\nFinland\nM\nSummer\nSwimming\nBronze\n\n\n16\nFinland\nM\nWinter\nIce Hockey\nBronze\n\n\n17\nFinland\nM\nSummer\nGymnastics\nBronze\n\n\n...\n...\n...\n...\n...\n...\n\n\n135553\nSoviet Union\nF\nSummer\nAthletics\nSilver\n\n\n135553\nSoviet Union\nF\nSummer\nAthletics\nBronze\n\n\n135554\nPoland\nM\nSummer\nFencing\nBronze\n\n\n135563\nRussia\nF\nSummer\nAthletics\nBronze\n\n\n135563\nRussia\nF\nSummer\nAthletics\nSilver\n\n\n\n\n39783 rows × 5 columns\n\n\n\n\n# here we see a high percentage of null values in medal because only some of the athletes win the medal\n\n# Create a new DataFrame with the converted 'target' column\nnew_athletes = athletes.copy()  # Make a copy to avoid modifying the original DataFrame\n\n# Convert the 'medal' column to 'target' based on the medal values\nnew_athletes['target'] = new_athletes['medal'].apply(lambda x: 'gold' if x =='Gold' else 'no gold')\n\n\nnew_athletes\n\n\n\n\n\n\n\n\ncountry\nsex\nseason\nsport\nmedal\ntarget\n\n\nID\n\n\n\n\n\n\n\n\n\n\n4\nDenmark/Sweden\nM\nSummer\nTug-Of-War\nGold\ngold\n\n\n15\nFinland\nM\nSummer\nSwimming\nBronze\nno gold\n\n\n15\nFinland\nM\nSummer\nSwimming\nBronze\nno gold\n\n\n16\nFinland\nM\nWinter\nIce Hockey\nBronze\nno gold\n\n\n17\nFinland\nM\nSummer\nGymnastics\nBronze\nno gold\n\n\n...\n...\n...\n...\n...\n...\n...\n\n\n135553\nSoviet Union\nF\nSummer\nAthletics\nSilver\nno gold\n\n\n135553\nSoviet Union\nF\nSummer\nAthletics\nBronze\nno gold\n\n\n135554\nPoland\nM\nSummer\nFencing\nBronze\nno gold\n\n\n135563\nRussia\nF\nSummer\nAthletics\nBronze\nno gold\n\n\n135563\nRussia\nF\nSummer\nAthletics\nSilver\nno gold\n\n\n\n\n39783 rows × 6 columns\n\n\n\n\n#I just want to include four sports in which US generally do good\n\nselected_sports = ['Swimming']\n\nrecent_athletes = new_athletes[new_athletes['sport'].isin(selected_sports)]\n\n\nrecent_athletes.apply(pd.isnull).sum()\nrecent_athletes\n\n\n\n\n\n\n\n\ncountry\nsex\nseason\nsport\nmedal\ntarget\n\n\nID\n\n\n\n\n\n\n\n\n\n\n15\nFinland\nM\nSummer\nSwimming\nBronze\nno gold\n\n\n15\nFinland\nM\nSummer\nSwimming\nBronze\nno gold\n\n\n100\nHungary\nM\nSummer\nSwimming\nBronze\nno gold\n\n\n259\nCanada\nF\nSummer\nSwimming\nBronze\nno gold\n\n\n424\nSouth Africa\nF\nSummer\nSwimming\nBronze\nno gold\n\n\n...\n...\n...\n...\n...\n...\n...\n\n\n135302\nWest Germany\nF\nSummer\nSwimming\nBronze\nno gold\n\n\n135396\nNetherlands\nM\nSummer\nSwimming\nBronze\nno gold\n\n\n135415\nSoviet Union\nM\nSummer\nSwimming\nGold\ngold\n\n\n135489\nRussia\nF\nSummer\nSwimming\nSilver\nno gold\n\n\n135522\nNetherlands\nM\nSummer\nSwimming\nSilver\nno gold\n\n\n\n\n3048 rows × 6 columns\n\n\n\n\n#lets drop silver medals and gold medals because we are only interested in Gold medals\n\n#athletes = athletes[athletes['medal'] == 'Gold'].dropna(subset=['medal'])\n\n\n# Create a new DataFrame with the converted columns\nplayers = recent_athletes.copy()  # Make a copy to avoid modifying the original DataFrame\n\n# Convert the 'country' column to numerical values\nplayers['country'] = (recent_athletes['country'] == 'United States').astype(int)\n\n# Convert the 'sex' column to numerical values\nplayers['sex'] = (recent_athletes['sex'] == 'M').astype(int)\n\n\n# Convert the 'season' column to numerical values\nplayers['season'] = (recent_athletes['season'] == 'Summer').astype(int)\n\n# Convert the 'sport' column to numerical values\nplayers['sport'] = (recent_athletes['sport'] == 'Swimming').astype(int)\n\n\n#since we are only interested in swimming data let's drop others\n\n#athletes = athletes[athletes['sport'] == 'Swimming'].dropna(subset=['sport'])\n\n\nplayers\n\n\n\n\n\n\n\n\ncountry\nsex\nseason\nsport\nmedal\ntarget\n\n\nID\n\n\n\n\n\n\n\n\n\n\n15\n0\n1\n1\n1\nBronze\nno gold\n\n\n15\n0\n1\n1\n1\nBronze\nno gold\n\n\n100\n0\n1\n1\n1\nBronze\nno gold\n\n\n259\n0\n0\n1\n1\nBronze\nno gold\n\n\n424\n0\n0\n1\n1\nBronze\nno gold\n\n\n...\n...\n...\n...\n...\n...\n...\n\n\n135302\n0\n0\n1\n1\nBronze\nno gold\n\n\n135396\n0\n1\n1\n1\nBronze\nno gold\n\n\n135415\n0\n1\n1\n1\nGold\ngold\n\n\n135489\n0\n0\n1\n1\nSilver\nno gold\n\n\n135522\n0\n1\n1\n1\nSilver\nno gold\n\n\n\n\n3048 rows × 6 columns\n\n\n\n\n# Split the data into features (X) and the target variable (y)\n# to preapre data for ML ready\n\nfrom sklearn.model_selection import train_test_split\nX = players[['country','sport', 'sex']]\ny = players['target']\n\n# Split the data into training and testing sets\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.5, random_state=42)\n\nplayers\n\n\n\n\n\n\n\n\ncountry\nsex\nseason\nsport\nmedal\ntarget\n\n\nID\n\n\n\n\n\n\n\n\n\n\n15\n0\n1\n1\n1\nBronze\nno gold\n\n\n15\n0\n1\n1\n1\nBronze\nno gold\n\n\n100\n0\n1\n1\n1\nBronze\nno gold\n\n\n259\n0\n0\n1\n1\nBronze\nno gold\n\n\n424\n0\n0\n1\n1\nBronze\nno gold\n\n\n...\n...\n...\n...\n...\n...\n...\n\n\n135302\n0\n0\n1\n1\nBronze\nno gold\n\n\n135396\n0\n1\n1\n1\nBronze\nno gold\n\n\n135415\n0\n1\n1\n1\nGold\ngold\n\n\n135489\n0\n0\n1\n1\nSilver\nno gold\n\n\n135522\n0\n1\n1\n1\nSilver\nno gold\n\n\n\n\n3048 rows × 6 columns\n\n\n\n\nX_test.shape\n\n(1524, 3)\n\n\n\nsns.countplot(data=players, x='target')\npl.title('Distribution of Target')\npl.show()\n\n\n\n\n\n# to train the naive model as out target is to use naive bayes model\n\n# we use gaussian naive bayes\n\nfrom sklearn.naive_bayes import GaussianNB\n\n# Create a Gaussian Naive Bayes model\nnb_model = GaussianNB()\n\n# Train the model on the training data\nnb_model.fit(X_train, y_train)\n\nGaussianNB()In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.GaussianNBGaussianNB()\n\n\n\n# now evaluating the model \n\n\nfrom sklearn.metrics import accuracy_score, classification_report\n\n# Predict on the test data\ny_pred = nb_model.predict(X_test)\n\n# Calculate accuracy\naccuracy = accuracy_score(y_test, y_pred)\nprint(\"Accuracy:\", accuracy)\n\n# Generate a classification report\nreport = classification_report(y_test, y_pred)\nprint(\"Classification Report:\\n\", report)\n\nAccuracy: 0.7099737532808399\nClassification Report:\n               precision    recall  f1-score   support\n\n        gold       0.59      0.58      0.58       537\n     no gold       0.77      0.78      0.78       987\n\n    accuracy                           0.71      1524\n   macro avg       0.68      0.68      0.68      1524\nweighted avg       0.71      0.71      0.71      1524\n\n\n\n\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nfrom sklearn.metrics import confusion_matrix\nfrom sklearn.naive_bayes import MultinomialNB\nfrom sklearn.model_selection import train_test_split\n\n# Assuming you have already trained your Naive Bayes model (nb_model) and split your data into training (X_train, y_train) and testing (X_test, y_test) sets.\n\n# Example data (replace with your actual data)\n# X_train, X_test, y_train, y_test = train_test_split(features, labels, test_size=0.2, random_state=42)\n# nb_model = MultinomialNB()\n# nb_model.fit(X_train, y_train)\n\n# Predict on the test data\ny_pred = nb_model.predict(X_test)\n\n# Create a confusion matrix\ncm = confusion_matrix(y_test, y_pred)\n\n# Create a heatmap using seaborn\nplt.figure(figsize=(8, 6))\nsns.heatmap(cm, annot=True, fmt=\"d\", cmap=\"Blues\", xticklabels=np.unique(y_test), yticklabels=np.unique(y_test))\nplt.title('Confusion Matrix')\nplt.xlabel('Predicted')\nplt.ylabel('Actual')\nplt.show()\n\n\n\n\n\n# Assuming you have the classification report stored in the 'report' variable\nreport = classification_report(y_test, y_pred, output_dict=True)\n\n# Convert the classification report to a DataFrame for easier plotting\nplayers_report = pd.DataFrame(report).transpose()\n\n# Create a horizontal bar chart using Seaborn\npl.figure(figsize=(8, 4))\nsns.set(style=\"whitegrid\")\nsns.set_palette(\"pastel\")\nax = sns.barplot(x=players_report['f1-score'], y=players_report.index, orient=\"h\")\nax.set(xlabel='F1-Score', ylabel='Metric')\npl.title('Classification Report Metrics')\npl.show()\n\n\n\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom sklearn.metrics import precision_recall_curve, roc_curve, auc\nfrom sklearn.naive_bayes import MultinomialNB\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import label_binarize\n\n# Assuming you have already trained your Naive Bayes model (nb_model) and split your data into training (X_train, y_train) and testing (X_test, y_test) sets.\n\n# Example data (replace with your actual data)\n# X_train, X_test, y_train, y_test = train_test_split(features, labels, test_size=0.2, random_state=42)\n# nb_model = MultinomialNB()\n# nb_model.fit(X_train, y_train)\n\n# Predict probabilities on the test data\ny_probs = nb_model.predict_proba(X_test)[:, 1]\n\n# Binarize the target variable\ny_test_binary = label_binarize(y_test, classes=np.unique(y_test))\n\n# Calculate precision-recall curve\nprecision, recall, _ = precision_recall_curve(y_test_binary, y_probs)\n\n# Calculate ROC curve\nfpr, tpr, _ = roc_curve(y_test_binary, y_probs)\n\n# Calculate area under the curves (AUC)\npr_auc = auc(recall, precision)\nroc_auc = auc(fpr, tpr)\n\n# Plot Precision-Recall curve\nplt.figure(figsize=(8, 6))\nplt.plot(recall, precision, color='darkorange', lw=2, label=f'PR Curve (AUC = {pr_auc:.2f})')\nplt.xlabel('Recall')\nplt.ylabel('Precision')\nplt.title('Precision-Recall Curve')\nplt.legend(loc='best')\nplt.show()\n\n# Plot ROC curve\nplt.figure(figsize=(8, 6))\nplt.plot(fpr, tpr, color='darkblue', lw=2, label=f'ROC Curve (AUC = {roc_auc:.2f})')\nplt.plot([0, 1], [0, 1], color='gray', lw=1, linestyle='--')\nplt.xlabel('False Positive Rate')\nplt.ylabel('True Positive Rate')\nplt.title('Receiver Operating Characteristic (ROC) Curve')\nplt.legend(loc='best')\nplt.show()"
  }
]